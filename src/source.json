{
    "complexities":
        [
            {"symbol": "O(n log n)",
             "examples":
                [
                    {"name": "Mergesort",
                     "gif": "merge.gif"},
                    {"name": "Timsort",
                     "gif": "tim.gif"},
                    {"name": "Heapsort",
                     "gif": "heap.gif"},
                     {"name": "Quicksort",
                     "gif": "quick.gif"}
                ],
             "image": "third.png",
             "description": "THIRD"
            },
            {"symbol": "O(N^2)",
            "examples":
                    [
                        {"name": "Bubble sort",
                         "gif": "bubble.gif",
                         "description": "The simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst-case time complexity is quite high."},
                         {"name": "Insertion sort",
                         "gif": "insertion.gif"},
                        {"name": "Selection sort",
                         "gif": "selection.gif"},
                        {"name": "Tree sort",
                         "gif": "tree.gif"},
                        {"name": "Bucket Sort",
                         "gif": "bucket.gif"}
                    ],
             "image": "On2.png",
             "description": "Quadratic time complexity. Often reflects the fact that the algorithm processes all (or a substantial number of) pairs of elements in a given input set. In the code it usually looks like a for loop embedded inside of another for loop. The examples are basic sorting algorithms like bubble, insertion or selection sort.",
             "resources": [],
             "rank": "bad"
            }, 
            {"symbol": "O(n(log(n))^2)",
             "examples": 
                [
                    {"name": "Shell sort",
                     "gif": "shell.gif"}
                ]},
            {"symbol": "O(nk)",
            "examples": 
                [
                    {"name": "Radix sort",
                     "gif": "radix.gif"}
                ]},
            {"symbol": "O(n+k)",
            "examples": 
                [
                    {"name": "Counting sort",
                     "gif": "counting.gif"}
                ]},
            {"symbol": "O(N)",
             "examples": [],
             "image": "On.png",
             "description": "As N increases, so does the amount of operations needed to complete the problem. This is simple to understand because itâ€™s an entirely linear relationship."}
        ]
}